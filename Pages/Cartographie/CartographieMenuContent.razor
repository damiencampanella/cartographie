@namespace BlazorFlowly.Pages.Cartographie

@using BlazorLeaflet.Models.Events
@using BlazorLeaflet.Models;
@using BlazorFlowly.Components;
@using System.Globalization
@using System.Timers
@using System.Diagnostics

@inject IJSRuntime jsRuntime
@inject IMapDataService MapDataService
@inject IPositionsDataService PositionsDataService
@inject IStopTimesDataService StopTimesDataService
@inject Microsoft.Extensions.Localization.IStringLocalizer<App> Localize
@inject Microsoft.Extensions.Configuration.IConfiguration config
@inject NavigationManager navigationManager

@if (DisplayMenu) {
    @if (mapInitializationDone) {
        <ul class="nav nav-tabs" id="tabs_carto">
            <li class="nav-item">
                <a style="margin-left:4pt;" class="nav-link active" data-toggle="tab" href="#lines">
                    <span class="carto_tab"><i class="fas fa-code-branch tab_icon"></i> @GetLocalizedString("Lignes")</span>
                </a>
            </li>
            @if (!CollapsedSider) {
                <li class="nav-item">
                    <a class="nav-link" data-toggle="tab" href="#selection">
                        <span class="carto_tab"><i class="fas fa-list-ul tab_icon"></i> @GetLocalizedString("Sélection")</span>
                    </a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" data-toggle="tab" href="#vehicles">
                        <span class="carto_tab"><i class="fas fa-map-marker-alt tab_icon"></i> @GetLocalizedString("Véhicules")</span>
                    </a>
                </li>
            }
        </ul>
        <div class="tab-content">
            <div id="lines" class="tab-pane active" style="padding-top: 10pt;">
                @{
                    string lineDivString;
                    if (isMobileView) {
                        lineDivString = $"max-height:{GetHeaderHeight()}px; overflow-y:scroll; overflow-x:hidden;";
                    }
                    else {
                        lineDivString = $"max-height:calc(100vh - 170px); ; overflow-y:auto; padding-top: 10pt;";
                    }

                    <div id="lines_subdiv" style=@lineDivString>
                        @if (CollapsedSider) {
                            foreach (LineSelection selectedLine in SelectedLines) {
                                Flowly.Api.Map.ApiLine line = linesDict[selectedLine.LineId];
                                <TooltipComponent Title="@line.Name">
                                    <div @onmouseenter="() => LineButtonMouseEnterEvent(selectedLine)" @onmouseleave="() => LineButtonMouseLeaveEvent(selectedLine)">
                                        <button class="btn" style="@(LineButtonFormattingString(line.ForeColor, line.Color, selectedLine.Display, lineButtonWidth*5/4))"
                                                @onclick="() => LineButtonClickHandler(selectedLine)">@RemoveLineFromString(line.Id)
                                        </button>
                                    </div>
                                </TooltipComponent>
                            }
                        }
                        else {
                            string emptyString = "";
                            <div style="padding: 0pt 10pt 0pt 10pt">
                                <div class="container-fluid" style="padding:0;">
                                    <div class="row" style="margin-top: 5pt; margin-left: -8px; margin-right: -8px; row-gap: 16px">
                                        @foreach (string category in linesByCategoryDict.Keys){
                                            if(category == emptyString) {
                                                continue;
                                            }
                                            <div class="col-12 d-flex flex-row align-items-center justify-content-between" style="padding:0">
                                                <div><b style="@(LineCategoryFormattingString())">@category</b></div>
                                                <button type="button" class="btn btn-outline-primary  btn-sm" style="border-radius: 5px; margin-right: 9pt;" @onclick="() => ToggleCategoryHide(category)">
                                                        @if (categoryHideDict[category]) {
                                                            <TooltipComponent Title="@GetLocalizedString("Afficher cette catégorie")" Placement="top">
                                                                <span><i class="fas fa-eye carto_button_icon small"></i></span>
                                                            </TooltipComponent>
                                                        }
                                                        else {
                                                            <TooltipComponent Title="@GetLocalizedString("Masquer cette catégorie")" Placement="top">
                                                                <span><i class="fas fa-eye-slash carto_button_icon small"></i></span>
                                                            </TooltipComponent>
                                                        }
                                                </button>
                                            </div>
                                            @foreach(var lineId in linesByCategoryDict[category]) {
                                                LineSelection selectedLine = GetSelectedLine(lineId);
                                                Flowly.Api.Map.ApiLine line = linesDict[lineId];
                                                <div class="col-3" style="padding:0">
                                                    <TooltipComponent Title="@line.Name">
                                                        <div @onmouseenter="() => LineButtonMouseEnterEvent(selectedLine)" @onmouseleave="() => LineButtonMouseLeaveEvent(selectedLine)">
                                                            <button class="btn" style="@(LineButtonFormattingString(line.ForeColor, line.Color, selectedLine.Display, lineButtonWidth))"
                                                                    @onclick="() => LineButtonClickHandler(selectedLine)">@RemoveLineFromString(line.Id)
                                                            </button>
                                                        </div>
                                                    </TooltipComponent>
                                                </div>
                                            }
                                        }
                                        <div class="col-12 d-flex flex-row align-items-center justify-content-between" style="padding:0">
                                            <div><b style="@(LineCategoryFormattingString())">@GetLocalizedString("Autres Lignes")</b></div>
                                            <button type="button" class="btn btn-outline-primary btn-sm" style="border-radius: 5px; margin-right: 9pt;" @onclick="() => ToggleCategoryHide(emptyString)">
                                                    @if (categoryHideDict[emptyString]) {
                                                        <TooltipComponent Title="@GetLocalizedString("Afficher cette catégorie")" Placement="top">
                                                            <span><i class="fas fa-eye carto_button_icon small"></i></span> 
                                                        </TooltipComponent>
                                                    }
                                                    else {
                                                        <TooltipComponent Title="@GetLocalizedString("Masquer cette catégorie")" Placement="top">
                                                            <span><i class="fas fa-eye-slash carto_button_icon small"></i></span> 
                                                        </TooltipComponent>
                                                    }
                                            </button>
                                        </div>
                                        @foreach(var lineId in linesByCategoryDict[emptyString]) {
                                            LineSelection selectedLine = GetSelectedLine(lineId);
                                            Flowly.Api.Map.ApiLine line = linesDict[lineId];
                                            <div class="col-3" style="padding:0">
                                                <TooltipComponent Title="@line.Name">
                                                    <div @onmouseenter="() => LineButtonMouseEnterEvent(selectedLine)" @onmouseleave="() => LineButtonMouseLeaveEvent(selectedLine)">
                                                        <button class="btn" style="@(LineButtonFormattingString(line.ForeColor, line.Color, selectedLine.Display, lineButtonWidth))"
                                                                @onclick="() => LineButtonClickHandler(selectedLine)">@RemoveLineFromString(line.Id)
                                                        </button>
                                                    </div>
                                                </TooltipComponent>
                                            </div>
                                        }
                                    </div>
                                </div>
                            </div>
                        }
                    </div>
                    @if (!CollapsedSider){
                        <div class="container">
                            <div class="row">
                                <div class="col text-center">
                                    <button type="button" class="btn btn-outline-primary carto_bottom_button" @onclick=ToggleLineRemoval>
                                            @if (removeLines){
                                                <span><i class="fas fa-eye-slash carto_button_icon small"></i></span> 
                                                <span class="carto_button_text small">@GetLocalizedString("Lignes Masquées")</span>
                                            }
                                            else{
                                                <span><i class="fas fa-eye carto_button_icon small"></i></span>
                                                <span class="carto_button_text small">@GetLocalizedString("Lignes Grisées")</span>
                                            }
                                    </button>
                                </div>
                            </div>
                        </div>
                    }
                }
            </div>
            @if (!CollapsedSider){
                <div id="selection" class="tab-pane fade">
                    @{
                        string selectionDivString;
                        if(isMobileView) {
                            selectionDivString = $"max-height:{GetHeaderHeight()}px; overflow-y:scroll; overflow-x:hidden;";
                        }
                        else {
                            selectionDivString = $"max-height: calc(100vh - 155px); overflow-y:auto; overflow-x:hidden; padding-top: 10pt;";
                        }
                        
                        <div id="selection_subdiv" style=@selectionDivString>
                            @foreach (LineSelection selectedLine in SelectedLines){
                                @if(selectedLine.Display){
                                    Flowly.Api.Map.ApiLine line = linesDict[selectedLine.LineId];
                                    Flowly.Api.Map.ApiVariation selectedVariation = line.Roads[selectedLine.Direction].Variations[selectedLine.VariationNumber];
                                    string linkStyle = $"font-size: 12pt; display: inline-block; width: 155pt; vertical-align: middle;";
                                    string divStyle = $"word-spacing: {lineSelectionWordSpacing}px; margin: 3.5pt 0pt 3.5pt 3.5pt;";
                                    <div style=@divStyle>
                                        <button class="btn" style="@(LineButtonFormattingString(line.ForeColor, line.Color, true, 70))" 
                                                        @onclick="() => ToggleSelectedLineDevelopment(selectedLine)">
                                            @RemoveLineFromString(line.Id)
                                        </button>
                                        <a href="" @onclick="@(() => ToggleSelectedLineDevelopment(selectedLine))" @onclick:preventDefault style=@linkStyle>@selectedVariation.Description</a>
                                        <TooltipComponent Title="@GetLocalizedString("Changer de direction")" Placement="top">
                                            <button type="button" class="btn btn-outline-primary btn-sm" style="border-radius: 5px; padding: 0.5rem 0.7rem" @onclick="() => ChangeSelectedLineDirection(selectedLine)">
                                                @if (selectedLine.Direction == 0) {
                                                    <span><i class="fas fa-arrow-right"></i></span>     
                                                }
                                                else {
                                                    <span><i class="fas fa-arrow-left"></i></span>  
                                                }
                                            </button>
                                        </TooltipComponent>
                                        <TooltipComponent Title="@GetLocalizedString("Enlever de la sélection")" Placement="top">
                                            <button type="button" class="btn btn-outline-primary btn-sm" style="border-radius: 5px; padding: 0.5rem 0.7rem;" 
                                                     @onclick="() => RemoveSelectedLineFromDisplay(selectedLine)">
                                                <i class="fas fa-times carto_button_icon"></i>
                                            </button>
                                        </TooltipComponent>
                                    </div>
                                    @if((selectedLine != SelectedLines[SelectedLines.Length-1]) && !selectedLine.Develop) {
                                        <span class="horizontal_divider" style="margin: 10pt 0" />
                                    }
                                    @if (selectedLine.Develop) {
                                        Flowly.Api.Map.ApiRoad selectedRoad = line.Roads[selectedLine.Direction];
                                        @if (selectedRoad.Variations.Length > 1) {
                                            <div class="container-fluid" style="padding:0;">
                                                <div class="row g-2" style="margin: 7pt -9pt 7pt 7pt;">
                                                    @foreach (Flowly.Api.Map.ApiVariation variation in selectedRoad.Variations) {
                                                            float opacity = 1.0f - ((float)variation.Id / (float)selectedRoad.Variations.Length);
                                                            <div class="col" style="padding:0;">
                                                            <button class="btn" style="@(VariantButtonFormattingString(line.Color, opacity))"
                                                                    @onclick="() => ChangeSelectedVariation(selectedLine, variation.Id)">
                                                                <p class="mb-0" style="@(VariantTextFormattingString(line.ForeColor, opacity))">@variation.Description</p>
                                                            </button>
                                                        </div>
                                                    }
                                                </div>
                                            </div>
                                        }
                                        <ul class="station-list">
                                            @foreach (var stationRef in selectedVariation.Stations) {
                                                Flowly.Api.Map.ApiStation station = stationsDict[stationRef.Id];
                                                int stationIndex = Array.IndexOf(selectedVariation.Stations, stationRef);
                                                string spanStyle = $"background-color:#{line.Color}; position:absolute; top:0; bottom:0;";
                                                @if(stationRef == selectedVariation.Stations[0]) {
                                                    spanStyle += "border-radius: 3px 3px 0px 0px";
                                                }
                                                @if(stationRef == selectedVariation.Stations[selectedVariation.Stations.Length - 1]) {
                                                    spanStyle += "border-radius: 0px 0px 3px 3px";
                                                }
                                                <li class="station-list-item" @onmouseenter="() => StationMouseEnterEvent(selectedLine, stationIndex)" 
                                                        @onclick="() => StationClickEvent()" @onmouseleave="() => StationMouseLeaveEvent(selectedLine, stationIndex)">

                                                    <span style=@spanStyle><i style="color: white; font-size:7pt; margin: 3pt 3pt;" class="fas fa-circle"></i></span>
                                                    <span style="position: relative; left: 20pt" >@station.Name</span>
                                                    @foreach(var connectingLine in apiMap.Lines.Reverse()) {
                                                        if(stationsConnectionDict[stationRef.Id].Contains(connectingLine.Id) && (connectingLine.Id != selectedLine.LineId)) {
                                                            Flowly.Api.Map.ApiLine correspondingLine = linesDict[connectingLine.Id];
                                                            <span class="badge"  style="@(LineIconFormattingString(correspondingLine.ForeColor, correspondingLine.Color, 22, 18))">
                                                                @RemoveLineFromString(connectingLine.Id)
                                                            </span>  
                                                        }
                                                    }
                                                </li>
                                            }
                                        </ul>
                                        <span class="horizontal_divider"/>
                                    } @* if *@
                                } @* if *@
                            } @* foreach *@
                        </div>
                    }
                    <div class="container">
                        <div class="row">
                            <div class="col text-center">
                            @if(CheckIfAllLinesAreHidden()) {
                                <button type="button" class="btn btn-outline-primary carto_bottom_button" style="transform: none; left:27px;" @onclick=DisplayAllLines>
                                        <span><i class="fas fa-eye carto_button_icon small"></i></span>
                                        <span class="carto_button_text small">@GetLocalizedString("Afficher toutes les lignes")</span>
                                </button> 
                            }
                            else {
                                <button type="button" class="btn btn-outline-primary carto_bottom_button" style="transform: none; left:27px;" @onclick=HideAllLines>
                                        <span><i class="fas fa-times carto_button_icon small"></i></span>
                                        <span class="carto_button_text small">@GetLocalizedString("Masquer toutes les lignes")</span>
                                </button>
                            }

                            </div>
                        </div>
                    </div>
                </div>
                @if (DisplayVehicles) {
                    <div id="vehicles" class="tab-pane fade">
                        @if(vehicleInitializationDone) {
                            string vehicleDivStyleString;
                            if(isMobileView) {
                                vehicleDivStyleString = $"max-height:{GetHeaderHeight()}px; overflow-y:scroll; overflow-x:hidden; display: block";
                            }
                            else {
                                vehicleDivStyleString = $"max-height:calc(100vh - 155px); overflow-y:auto; overflow-x:hidden; padding-top: 10pt;";
                            }
                            <div id="vehicles_subdiv" class="px-2" style=@vehicleDivStyleString>


                                <div class="input-group">
                                    <input class="form-control" style="width: 90%; height: 30pt;" type="text" @bind-value="@vehicleFilteringString" @bind-value:event="oninput"
                                           placeholder=@GetLocalizedString("Rechercher parmi les véhicules") @onkeyup="() => FilterVehicles()">
                                    <button type="button" class="btn bg-transparent" style="color:grey; margin-left: -35px; z-index: 5; border: 0;" @onclick=OnVehicleSearchClear>
                                        <i class="far fa-times-circle"></i>
                                    </button>
                                    <div class="input-group-btn">
                                        <button class="btn btn-default" style="height: 30pt;" type="submit" @onclick="() => FilterVehicles()">
                                            <i style="color:grey;" class="fas fa-search"></i>
                                        </button>
                                    </div>
                                </div>

                                @foreach (VehicleInfo vehicleInfo in vehiclesInfo) {
                                    if(!vehicleInfo.Filtered) {
                                        <div @onmouseenter="() => VehicleMouseEnterEvent(vehicleInfo.Layer)" @onmouseleave="() => VehicleMouseLeaveEvent(vehicleInfo.Layer)">
                                            <button class="btn text-secondary btn-outline-light border-0" style="width: 100%; text-align: left; height: auto; border-radius: 5px;" @onclick="() => VehicleClickEvent(vehicleInfo.Position)">
                                                <span>
                                                    <span>
                                                        <i style="@StateCircleFormattingString(vehicleInfo.Position.State, 6)" class="fas fa-circle"></i>
                                                        <i style="color: black; font-size: 10pt;" class=@vehicleInfo.Position.Icon></i>
                                                    </span>
                                                    @if((vehicleInfo.Position.Vehicle != null) && (vehicleInfo.Position.VehicleId != null)) {
                                                        <b style="font-size: 12pt;">@vehicleInfo.Position.Vehicle</b>
                                                        <span style="font-size: 12pt;">(@vehicleInfo.Position.VehicleId)</span>
                                                    }
                                                    else {
                                                        <span style="font-size: 12pt;">@GetLocalizedString("Non Renseigné")</span>
                                                    }
                                                    @foreach (ApiDevice device in vehicleInfo.Position.Devices) {
                                                        string spanContent = $"{device.DeviceId}";
                                                        <div style="margin:0;"><i style="@StateCircleFormattingString(device.State, 4)" class="fas fa-circle"></i>
                                                        <span style="font-size:9pt; word-spacing:4pt;">@spanContent</span></div>
                                                    }
                                                </span>
                                                <span style="position: relative;">
                                                    <i style="@PeopleIconFormattingString(vehicleInfo.Position.Load)" class="fas fa-users"></i>
                                                </span>
                                            </button>
                                        </div>
                                    }
                                } @* foreach *@
                            </div>
                            <div class="container">
                                <div class="row">
                                    <div class="col text-center">
                                        <button type="button" class="btn btn-outline-primary carto_bottom_button" @onclick=ToggleVehiclesDisplay>
                                                @if (hideVehicles){
                                                    <span><i class="fas fa-eye carto_button_icon small"></i></span>
                                                    <span class="carto_button_text small">@GetLocalizedString("Afficher les véhicules")</span>
                                                }
                                                else{
                                                    <span><i class="fas fa-eye-slash carto_button_icon small"></i></span>
                                                    <span class="carto_button_text small">@GetLocalizedString("Masquer les véhicules")</span>
                                                }
                                        </button>
                                    </div>
                                </div>
                            </div>
                        }
                        else
                        {
                            <b>@GetLocalizedString("Accès à la position des véhicules impossible")</b>
                        }
                    </div>
                }
            }
        </div>
    }
    else
    {
        <div style="text-align: center;"><b> @GetLocalizedString("Chargement des données de cartographie") </b></div>
        <div class="d-flex justify-content-center">
            <div class="spinner-border" role="status">
            </div>
        </div>
    }  
}


@code {
    [Parameter]
    public CartographieComponent Parent  { get; set; }
    [Parameter]
    public bool CollapsedSider { get; set; } = false;
    [Parameter]
    public bool DisplayVehicles { get; set; } = true;
    [Parameter]
    public bool DisplayMenu { get; set; } = true;
    [Parameter]
    public bool DisplayOneLine { get; set; } = false;
    [Parameter]
    public string LineToDisplay { get; set; } = "";
    [Parameter]
    public int DirectionToDisplay { get; set; } = 0;
    [Parameter]
    public int VariantToDisplay { get; set; } = 0;

    private bool isMobileView;
    private int lineButtonWidth;
    private int menuWidth;
    private int windowHeight;

    private string lineSelectionWordSpacing;

    private bool mapInitializationDone = false;
    private bool vehicleInitializationDone = false;

    const int NUMBER_LAYERS_POLYLINE =  3;
    const int NUMBER_DISPLAYED_STOPTIMES = 3;


    private ApiMap apiMap = null;
    private ApiPositions apiPositions = null;
    private ApiStopTimes apiStopTimes = null;
    private Dictionary<string,Flowly.Api.Map.ApiStation> stationsDict;
    private Dictionary<string, HashSet<string>> stationsConnectionDict;
    private Dictionary<string,Flowly.Api.Map.ApiLine> linesDict;
    private Dictionary<string, List<string>> linesByCategoryDict;
    private Dictionary<string, bool> categoryHideDict;
    private BlazorLeaflet.Models.Icon stationIcon = new BlazorLeaflet.Models.Icon { Url = "assets/Station.png", Width = 10, Height = 10};
    private BlazorLeaflet.Models.Icon terminusIcon = new BlazorLeaflet.Models.Icon { Url = "assets/Terminus.png", Width = 10, Height = 10};
    public LineSelection[] SelectedLines { get; set; }
    private Dictionary<string, Layer[]> lineLayersDict = new();
    private Dictionary<string, ApiStopTime[]> stopTimesDict;  // "LineId Direction VariationId StationId" -> StopTimes
    private bool hideVehicles;
    private bool removeLines = true;
    private string vehicleFilteringString = "";
    private List<VehicleInfo> vehiclesInfo;
    private bool closeStationPopup = true;

    #if DEBUG
    private Stopwatch stopWatch;
    #endif


    protected override async Task OnInitializedAsync(){
        #if DEBUG
    stopWatch = Stopwatch.StartNew();
        #endif

        await base.OnInitializedAsync();

        isMobileView = Parent.isMobileView;
        lineButtonWidth = Parent.lineButtonWidth;
        lineSelectionWordSpacing = Parent.lineSelectionWordSpacing;
        menuWidth = Parent.menuWidth;
        windowHeight = Parent.WindowHeight;
        string configUrl = config["ApiUrl"];
        if (String.IsNullOrEmpty(configUrl)) {
            Uri uri = new Uri(navigationManager.BaseUri);
            configUrl = uri.Scheme + "://" + uri.Host + "/";
        }

        Task<ApiStopTimes> stopTimesTask = null;
        Task<ApiMap> mapTask = null;
        Task<ApiPositions> positionsTask = null;
        try
        {
            stopTimesTask = Task.Run<ApiStopTimes>(() => StopTimesDataService.GetApiStopTimesDataAsync(configUrl));  

            mapTask = Task.Run<ApiMap>(() => MapDataService.GetApiMapDataAsync(configUrl));

            if(DisplayVehicles) {
                positionsTask = Task.Run<ApiPositions>(() => PositionsDataService.GetApiPositionsDataAsync(configUrl));
            }

            apiStopTimes = await stopTimesTask;

            #if DEBUG
    stopWatch.Stop();
    long milliSec = stopWatch.ElapsedMilliseconds;
    Console.WriteLine("  Total time taken to fetch stoptimes data: {0} milliseconds", milliSec);
    stopWatch.Restart();
            #endif

            if (apiStopTimes != null) {
                stopTimesDict = new(apiStopTimes.Lines.Length*apiStopTimes.Lines[0].Roads.Length*60); //60: arbitrary number to initialize the dict size
                foreach (Flowly.Api.StopTimes.ApiLine line in apiStopTimes.Lines) {
                    foreach (Flowly.Api.StopTimes.ApiRoad road in line.Roads) {
                        foreach (Flowly.Api.StopTimes.ApiVariation variation in road.Variations) {
                            foreach (Flowly.Api.StopTimes.ApiStation station in variation.Stations) {
                                string key = $"{line.Id} {road.Direction} {variation.Id} {station.Id}";
                                stopTimesDict.Add(key, station.StopTimes);
                            }
                        }
                    }
                }
            }
            else {
                Console.WriteLine("Error trying to get the stop times data, No stop times will be displayed.");
            }

            #if DEBUG
    stopWatch.Stop();
    milliSec = stopWatch.ElapsedMilliseconds;
    Console.WriteLine("  Total time taken to initialize stoptimes: {0} milliseconds", milliSec);
    stopWatch.Restart();
            #endif

            apiMap = await mapTask;

            #if DEBUG
    stopWatch.Stop();
    milliSec = stopWatch.ElapsedMilliseconds;
    Console.WriteLine("  Total time taken to fetch Map data: {0} milliseconds", milliSec);
    stopWatch.Restart();
            #endif

            if (apiMap != null) {
                //Fill dictionnaries
                stationsDict = new(apiMap.Stations.Length);
                stationsConnectionDict = new(apiMap.Stations.Length);
                foreach (Flowly.Api.Map.ApiStation station in apiMap.Stations) {
                    stationsDict.Add(station.Id, station);
                    stationsConnectionDict[station.Id] = new();
                }
                linesDict = new(apiMap.Lines.Length);
                foreach (Flowly.Api.Map.ApiLine line in apiMap.Lines) {
                    linesDict.Add(line.Id, line);
                }

                //Fill the selected lines structure with the variant 0 and direction 0 of all lines (which is the default value for these properties)
                if(DisplayOneLine) {
                    SelectedLines = new LineSelection[1];
                    var line = linesDict[LineToDisplay];
                    SelectedLines[0] = new LineSelection { LineId = line.Id, Display=line.Display, Direction=DirectionToDisplay, VariationNumber=VariantToDisplay};
                }
                else {
                    int index = 0;
                    SelectedLines = new LineSelection[apiMap.Lines.Length];
                    foreach (var line in apiMap.Lines)
                    {
                        SelectedLines[index++] = new LineSelection { LineId = line.Id, Display=line.Display };
                    }
                }



                // Initialize bounds
                if(DisplayOneLine) {
                    Flowly.Api.Map.ApiLine line = linesDict[LineToDisplay];
                    Flowly.Api.Map.ApiVariation variant = line.Roads[DirectionToDisplay].Variations[VariantToDisplay];
                    Single[] bounds = StringUtils.ExtractBoundsFromString(variant.Bounds);
                    Parent.map.FitBounds(new PointF(bounds[0], bounds[1]), new PointF(bounds[2], bounds[3]));
                }
                else {
                    Single[] bounds = StringUtils.ExtractBoundsFromString(apiMap.Bounds);
                    Parent.map.FitBounds(new PointF(bounds[0], bounds[1]), new PointF(bounds[2], bounds[3]));
                }


                //map.AddLayer(new TileLayer
                //{
                //    UrlTemplate = "https://a.tile.openstreetmap.org/{z}/{x}/{y}.png",
                //    Attribution = "&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors",
                //});

                Parent.map.AddLayer(new TileLayer
                    {
                        UrlTemplate = "https://api.mapbox.com/styles/v1/mapbox/streets-v9/tiles/256/{z}/{x}/{y}?access_token=pk.eyJ1IjoianNrdXphIiwiYSI6ImNpcmMyY28xNjAwNm5pZm5uYmd4NW5iOWUifQ.nIpza_SQ3UblVaMg-md2-A",
                        Attribution = "Données &copy; <a href=\"http://openstreetmap.org\">OpenStreetMap</a>, <a href=\"http://creativecommons.org/licenses/by-sa/2.0/\">CC-BY-SA</a>, Imagerie &copy; <a href=\"http://mapbox.com\">Mapbox</a>",
                    });

                ScaleOptions scaleOptions = new() { Imperial=false };
                Parent.map.AddScale(scaleOptions);

                #if DEBUG
    stopWatch.Stop();
    milliSec = stopWatch.ElapsedMilliseconds;
    Console.WriteLine("  Total time taken to initialize the map: {0} milliseconds", milliSec);
    stopWatch.Restart();
                #endif

                // Display all lines
                foreach (var selectedLine in SelectedLines)
                {
                    DisplaySelectedLineFirstTime(selectedLine);
                }

                InitializeCategories();

                mapInitializationDone = true;
            }
            else {
                Console.WriteLine("Error trying to get the map data, please try again later");
            }

            #if DEBUG
    stopWatch.Stop();
    milliSec = stopWatch.ElapsedMilliseconds;
    Console.WriteLine("  Total time taken for the lines configuration: {0} milliseconds", milliSec);
    stopWatch.Restart();
            #endif
            if(DisplayVehicles) {
                apiPositions = await positionsTask;

                #if DEBUG
        stopWatch.Stop();
    milliSec = stopWatch.ElapsedMilliseconds;
    Console.WriteLine("  Total time to fetch the vehicle positions: {0} milliseconds", milliSec);
    stopWatch.Restart();
                #endif

                if((apiPositions != null) && (apiPositions.Positions != null))
                {
                    DisplayAllVehicles();
                    FilterVehicles();
                    vehicleInitializationDone = true;
                }
                else {
                    Console.WriteLine("Error trying to get the vehicle positions, no vehicle will be displayed");
                }
            }

            #if DEBUG
    stopWatch.Stop();
    milliSec = stopWatch.ElapsedMilliseconds;
    Console.WriteLine("  Total time taken to initialize the vehicle positions: {0} milliseconds", milliSec);
            #endif

        }
        catch (Exception ex)
        {
            Console.WriteLine("Exception during the initialization, Message: " + ex.Message);
        }
        TimeZoneInfo conversion = TimeZoneConverter.TZConvert.GetTimeZoneInfo(apiMap.Location);
        DateTime time = TimeZoneInfo.ConvertTime(UnixTimeStampStringToDateTime(apiStopTimes.ServerTime), conversion);
        await JSInterops.SetServerTime(jsRuntime, time.Hour.ToString("00"), time.Minute.ToString("00"));

        // Timer to reload real time data every minute
        Timer reloadRealTimeTimer = new Timer(60000);
        reloadRealTimeTimer.Elapsed += ReloadRealTimeEvent;
        reloadRealTimeTimer.Enabled = true;  
    }

    protected override async Task OnAfterRenderAsync(bool firstRender) {
        await base.OnAfterRenderAsync(firstRender);
        await JSInterops.WindowResize(jsRuntime);
        await JSInterops.InitTooltips(jsRuntime);
        await JSInterops.InitPopovers(jsRuntime);
    }

    private void InitializeCategories() {
        linesByCategoryDict = new();
        categoryHideDict = new();
        foreach (LineSelection selectedLine in SelectedLines){
            Flowly.Api.Map.ApiLine line = linesDict[selectedLine.LineId];
            //string Category = String.IsNullOrEmpty(line.Category) ? GetLocalizedString("Autres Lignes") : line.Category;
            if (linesByCategoryDict.ContainsKey(line.Category)) {
                linesByCategoryDict[line.Category].Add(line.Id);
            }
            else {
                linesByCategoryDict.Add(line.Category, new List<string>() { line.Id });
                categoryHideDict.Add(line.Category,false);
            }
        }
    }

    private LineSelection GetSelectedLine(string LineId) {
        foreach (LineSelection selectedLine in SelectedLines) {
            if(selectedLine.LineId == LineId) {
                return selectedLine;
            }
        }
        return SelectedLines[0];
    }

    private void ReloadRealTimeEvent(object source, ElapsedEventArgs e) {
        Task.Run(async () => await ReloadRealTimeTask());
    }

    private async Task ReloadRealTimeTask() {

        string configUrl = config["ApiUrl"];
        if (String.IsNullOrEmpty(configUrl)) {
            Uri uri = new Uri(navigationManager.BaseUri);
            configUrl = uri.Scheme + "://" + uri.Host + "/";
        }

        if(DisplayVehicles) {
            try {
                apiPositions = await PositionsDataService.GetApiPositionsDataAsync(configUrl);

                if ((apiPositions != null) && (apiPositions.Positions != null)) {
                    if (!hideVehicles)
                    {
                        RemoveAllVehicles();
                        DisplayAllVehicles();
                        FilterVehicles();
                    }
                    vehicleInitializationDone = true;
                }
                else {
                    vehicleInitializationDone = false;
                }  
            }
            catch (Exception ex)
            {
                Console.WriteLine("Exception during the vehicle initialization, no vehicle will be displayed. Message: " + ex.Message + ex.StackTrace);
                vehicleInitializationDone = false;
            }
        }

        try
        {
            apiStopTimes = await StopTimesDataService.GetApiStopTimesDataAsync(configUrl);
            if (apiStopTimes != null) {
                //Update stopTimesDict
                stopTimesDict.Clear();
                foreach (Flowly.Api.StopTimes.ApiLine line in apiStopTimes.Lines) {
                    foreach (Flowly.Api.StopTimes.ApiRoad road in line.Roads) {
                        foreach (Flowly.Api.StopTimes.ApiVariation variation in road.Variations) {
                            foreach (Flowly.Api.StopTimes.ApiStation station in variation.Stations) {
                                string key = $"{line.Id} {road.Direction} {variation.Id} {station.Id}";
                                stopTimesDict.Add(key, station.StopTimes);
                            }
                        }
                    }
                }
                // Clear Connecting lines as it will be refilled with the next function
                foreach (Flowly.Api.Map.ApiStation station in apiMap.Stations) {
                    stationsConnectionDict[station.Id].Clear();
                }
                // Update the content of the station Popups
                foreach (LineSelection selectedLine in SelectedLines) {
                    Flowly.Api.Map.ApiLine line = linesDict[selectedLine.LineId];
                    Flowly.Api.Map.ApiVariation selectedVariation = line.Roads[selectedLine.Direction].Variations[selectedLine.VariationNumber];
                    int stationLayerIndex = NUMBER_LAYERS_POLYLINE;
                    foreach (var stationRef in selectedVariation.Stations) {
                        Layer[] layers = lineLayersDict[line.Id];
                        Layer stationLayer = layers[stationLayerIndex++];
                        stationLayer.Popup.Content = CreateStationPopupContent(selectedLine, stationRef.Id);
                        Parent.map.UpdatePopupContent(stationLayer);
                    }
                }
            }

            if (apiStopTimes != null) {
                TimeZoneInfo conversion = TimeZoneConverter.TZConvert.GetTimeZoneInfo(apiMap.Location);
                DateTime time = TimeZoneInfo.ConvertTime(UnixTimeStampStringToDateTime(apiStopTimes.ServerTime), conversion);
                await JSInterops.SetServerTime(jsRuntime, time.Hour.ToString("00"), time.Minute.ToString("00"));
            }

        }
        catch (Exception ex)
        {
            Console.WriteLine("Exception during the stop times initialization, no stop times will be displayed. Message: " + ex.Message);
        }


        StateHasChanged();
    }

    private void DisplaySelectedLineFirstTime(LineSelection selectedLine) {
        if (!lineLayersDict.ContainsKey(selectedLine.LineId)) {
            Flowly.Api.Map.ApiLine line = linesDict[selectedLine.LineId];
            Flowly.Api.Map.ApiVariation selectedVariation = line.Roads[selectedLine.Direction].Variations[selectedLine.VariationNumber];
            string color = line.Color;
            double opacity = 1.0;

            int colorInt = int.Parse(color, System.Globalization.NumberStyles.HexNumber);
            int weight = line.Weight;

            // Display the shape of the line variant
            PointF[][] shape = new PointF[1][];
            int shapeSize = selectedVariation.Shape.Count();
            shape[0] = new PointF[shapeSize];
            for (int i = 0; i<shapeSize; i++) {
                shape[0][i] = new PointF((float)selectedVariation.Shape[i][0], (float)selectedVariation.Shape[i][1]);
            }
            Layer[] lineLayers = new Layer[selectedVariation.Stations.Length+NUMBER_LAYERS_POLYLINE];
            var polyLineBorders = new Polyline {
                Shape = shape,
                Fill = false,
                StrokeWidth = weight + 9,
                StrokeOpacity = 1.0,
                StrokeColor = System.Drawing.Color.White,
                NoClipEnabled = false
            };
            Parent.map.AddLayer(polyLineBorders);
            lineLayers[0] = polyLineBorders;

            var polyLineMask = new Polyline {
                Shape = shape,
                Fill = false,
                StrokeWidth = weight + 5,
                StrokeColor = System.Drawing.Color.White,
                NoClipEnabled = false
            };
            Parent.map.AddLayer(polyLineMask);
            lineLayers[1] = polyLineMask;

            var polyLine = new Polyline {
                Shape = shape,
                Fill = false,
                StrokeWidth = weight + 5,
                StrokeColor = System.Drawing.Color.FromArgb(colorInt),
                StrokeOpacity = opacity,
                NoClipEnabled = false,
                Tooltip = new BlazorLeaflet.Models.Tooltip { 
                    IsSticky = true, 
                    Content = $"<span class=\"badge\" style=\"{LineIconFormattingString(line.ForeColor, line.Color, 22, 18)}\">{RemoveLineFromString(line.Id)}</span>" }             
            };
            Parent.map.AddLayer(polyLine);
            lineLayers[2] = polyLine;

            // Display all stations of the line variant
            int layerIndex = NUMBER_LAYERS_POLYLINE;
            foreach (var stationRef in selectedVariation.Stations) {
                Flowly.Api.Map.ApiStation station = stationsDict[stationRef.Id];
                BlazorLeaflet.Models.Icon icon = (station.Terminus) ? terminusIcon : stationIcon;
                string popupContent = CreateStationPopupContent(selectedLine, stationRef.Id);
                var stationMarker = new Marker((float)station.Latitude, (float)station.Longitude) {
                    Icon = icon,
                    Popup = new Popup {
                        Content = popupContent,
                        KeepInView = true,
                        ShowCloseButton = false
                    }
                };
                Parent.map.AddLayer(stationMarker);
                lineLayers[layerIndex++] = stationMarker;
            } //foreach
            lineLayersDict.Add(selectedLine.LineId, lineLayers);
        } //if
    }

    private string CreateStationPopupContent(LineSelection selectedLine, string stationId) {
        bool stopTimesFound;
        Flowly.Api.Map.ApiLine line = linesDict[selectedLine.LineId];
        Flowly.Api.Map.ApiStation station = stationsDict[stationId];
        string key = $"{selectedLine.LineId} {selectedLine.Direction} {selectedLine.VariationNumber} {stationId}";

        string stationPopupString = $"<div style= \"min-width:210pt; font-size: 10pt; height: 20pt; background-color: #e4e4e4; border-radius: 5px; padding:0.4rem;" +
                $"justify-content:center; text-align: center; margin:10pt 0pt; line-height: 11pt;\">{station.Name}</div>" +
                GetStopTimesLineString(line, key, out stopTimesFound);

        foreach(var connectingLine in apiMap.Lines) {
            if ((connectingLine.Id != selectedLine.LineId) && IsAmongTheStationConnectingLines(station, connectingLine.Id)) {
                string connectingStationId;
                int direction, variationNumber;
                LineSelection connectingSelectedLine = GetConnectingSelectedLine(connectingLine.Id);
                if (connectingSelectedLine != null) {
                    direction = connectingSelectedLine.Direction;
                    variationNumber = connectingSelectedLine.VariationNumber;
                }
                else {
                    //Values by default
                    direction = 0;
                    variationNumber = 0;

                }

                Flowly.Api.Map.ApiRoad selectedRoad = connectingLine.Roads[direction];
                stopTimesFound = StationAvailableInVariation(selectedRoad.Variations[variationNumber], station.Name, out connectingStationId);
                if (!stopTimesFound) {
                    // Check in selected direction if a variation contains the target station
                    foreach(var variation in selectedRoad.Variations) {
                        if(variation.Id != variationNumber) {
                            if(StationAvailableInVariation(variation, station.Name, out connectingStationId)) {
                                variationNumber = variation.Id;
                                stopTimesFound = true;
                                break;
                            }
                        }
                    }
                }

                if (!stopTimesFound) {
                    // Check in the opposite direction if a variation contains the target station
                    if (direction == 0) {
                        direction = 1;
                    }
                    else {
                        direction = 0;
                    }
                    selectedRoad = connectingLine.Roads[direction];
                    foreach(var variation in selectedRoad.Variations) {
                        if(StationAvailableInVariation(variation, station.Name, out connectingStationId)) {
                            variationNumber = variation.Id;
                            stopTimesFound = true;
                            break;
                        }
                    }
                }

                if(stopTimesFound) {
                    key = $"{connectingLine.Id} {direction} {variationNumber} {connectingStationId}";
                    string lineString = GetStopTimesLineString(connectingLine, key, out stopTimesFound);
                    if(stopTimesFound) {
                        stationPopupString += lineString;
                        stationsConnectionDict[stationId].Add(connectingLine.Id);
                    }
                }  
            }
        }
        return stationPopupString;
    }

    private void ToggleCategoryHide(string category) {
        if(categoryHideDict[category]) {
            categoryHideDict[category] = false;
            foreach( var selectedLine in SelectedLines)
            {
                Flowly.Api.Map.ApiLine line = linesDict[selectedLine.LineId];
                if (line.Category == category)
                {
                    DisplaySelectedLine(selectedLine, false);
                    DisplayVehiclesFromLine(selectedLine.LineId, true);
                    selectedLine.Display = true;
                }
            }
        }
        else {
            categoryHideDict[category] = true;
            foreach( var selectedLine in SelectedLines)
            {
                Flowly.Api.Map.ApiLine line = linesDict[selectedLine.LineId];
                if (line.Category == category)
                {
                    if(removeLines) {
                        HideSelectedLine(selectedLine);
                    } else {
                        DisplaySelectedLine(selectedLine, true);
                    }
                    HideVehiclesFromLine(selectedLine.LineId, true);
                    selectedLine.Display = false;
                    selectedLine.Develop = false;
                }
            }
        }
        HideVehiclesFromNonSelectedLines();
        StateHasChanged();
    }

    private bool CheckAllCategoryLinesDisplayStatus(string category, bool status) {
        foreach(var lineId in linesByCategoryDict[category]) {
            LineSelection selectedLine = GetSelectedLine(lineId);
            if(selectedLine.Display != status) {
                return false;
            }
        }
        return true;
    }

    private LineSelection GetConnectingSelectedLine(string Id) {
        foreach (var lineSelection in SelectedLines) {
            if (lineSelection.LineId == Id) {
                return lineSelection;
            }
        }
        return null;
    }

    private bool IsAmongTheStationConnectingLines(Flowly.Api.Map.ApiStation station, string LineId) {
        bool idFound = false;
        foreach (var line in station.Lines) {
            if (line.Id == LineId) {
                idFound = true;
            }
        }
        return idFound;
    }
    private bool StationAvailableInVariation(Flowly.Api.Map.ApiVariation variation, string stationName, out string stationId) {
        bool stationFound = false;
        stationId = "";
        foreach (var stationRef in variation.Stations) {
            Flowly.Api.Map.ApiStation station = stationsDict[stationRef.Id];
            if (station.Name == stationName) {
                stationFound = true;
                stationId = station.Id;
            }
        }
        return stationFound;
    }

    private string GetStopTimesLineString(Flowly.Api.Map.ApiLine line, string key, out bool stopTimesFound) {
        ApiStopTime[] stopTimes = null;
        stopTimesDict.TryGetValue(key, out stopTimes);
        string stopTimesHtmlString = "";
        if (stopTimes != null) {
            for (int stopTimeIndex = 0; stopTimeIndex<(stopTimes.Length-1); stopTimeIndex++) {
                stopTimesHtmlString += GetSingleStopTimeString(stopTimes[stopTimeIndex]) + " | ";
            }
            stopTimesHtmlString += GetSingleStopTimeString(stopTimes[stopTimes.Length-1]);
            stopTimesFound = true;
        } //if
        else {
            stopTimesHtmlString = " " + GetLocalizedString("Plus de passage aujourd'hui");
            stopTimesFound = false;
        }
        return $"<div style=\"margin-top: 2pt;\"><button class=\"badge\" style=\"font-size: 9pt; color: #{line.ForeColor}; background: #{line.Color}; width: {lineButtonWidth*6/10}px; height: 17pt;" +
               $"border-style: none; border-radius: 5px; padding: 0;\"> {RemoveLineFromString(line.Id)}</button>" +
               stopTimesHtmlString + "</div>";
    }

    private string GetSingleStopTimeString(ApiStopTime stopTime) {
        return $"<b> {FormatPassingTime(stopTime.PassingTime)} </b>" +
               $"{GetPopupLoadIcon(GetLoadColor(stopTime.Load))}" +
               $"{GetPopupRealTimeIcon(stopTime.IsRealTime)}";
    }

    private void RemoveSelectedLine(LineSelection selectedLine) {
        if(lineLayersDict.ContainsKey(selectedLine.LineId)) {
            Layer[] layers = lineLayersDict[selectedLine.LineId];
            foreach(Layer layer in layers){
                Parent.map.RemoveLayer(layer);
            }
            lineLayersDict.Remove(selectedLine.LineId); 
        }
    }

    private void DisplaySelectedLine(LineSelection selectedLine, bool greyPolyline) {
        if(lineLayersDict.ContainsKey(selectedLine.LineId)) {
            Flowly.Api.Map.ApiLine line = linesDict[selectedLine.LineId];
            string color = line.Color;
            double opacity = 1.0;
            if (greyPolyline) {
                color = "9FA6AD";
                opacity = 0.7;
            }
            int colorInt = int.Parse(color, System.Globalization.NumberStyles.HexNumber);
            int weight = line.Weight;

            Layer[] layers = lineLayersDict[selectedLine.LineId];
            int nbLayers = layers.Length;

            Path polyLineBorders = (Path)layers[0];
            polyLineBorders.Fill = false;
            polyLineBorders.StrokeWidth = weight + 9;
            polyLineBorders.StrokeOpacity = 0.5;
            polyLineBorders.StrokeColor = System.Drawing.Color.White;
            Parent.map.SetPathOptions((Path)polyLineBorders);

            Path polyLineMask = (Path)layers[1];
            polyLineMask.Fill = false;
            polyLineMask.StrokeWidth = weight + 5;
            polyLineMask.StrokeOpacity = 1.0;
            polyLineMask.StrokeColor = System.Drawing.Color.White;
            Parent.map.SetPathOptions((Path)polyLineMask);

            Path polyLine = (Path)layers[2];
            polyLine.Fill = false;
            polyLine.StrokeWidth = weight + 5;
            polyLine.StrokeOpacity = opacity;
            polyLine.StrokeColor = System.Drawing.Color.FromArgb(colorInt);
            Parent.map.SetPathOptions((Path)polyLine);

            List<String> markerIdList = new List<String>();
            for(int i =NUMBER_LAYERS_POLYLINE;i<nbLayers;i++) {
                markerIdList.Add(layers[i].Id);
            }
            Parent.map.SetMarkerOpacityIdList(markerIdList.ToArray(), 1.0f);
        }
    }

    private void HideSelectedLine(LineSelection selectedLine) {
        if(lineLayersDict.ContainsKey(selectedLine.LineId)) {
            Flowly.Api.Map.ApiLine line = linesDict[selectedLine.LineId];

            Layer[] layers = lineLayersDict[selectedLine.LineId];
            int nbLayers = layers.Length;

            Polyline polyLineBorders = (Polyline)layers[0];
            polyLineBorders.StrokeOpacity = 0.0;
            polyLineBorders.StrokeColor = System.Drawing.Color.Empty;
            polyLineBorders.Fill = false;
            Parent.map.SetPathOptions((Path)polyLineBorders);

            Polyline polyLineMask = (Polyline)layers[1];
            polyLineMask.StrokeOpacity = 0.0;
            polyLineBorders.StrokeColor = System.Drawing.Color.Empty;
            polyLineBorders.Fill = false;
            Parent.map.SetPathOptions((Path)polyLineMask);

            Polyline polyLine = (Polyline)layers[2];
            polyLine.StrokeOpacity = 0.0;
            polyLineBorders.StrokeColor = System.Drawing.Color.Empty;
            polyLineBorders.Fill = false;
            Parent.map.SetPathOptions((Path)polyLine);

            List<String> markerIdList = new List<String>();
            for(int i =NUMBER_LAYERS_POLYLINE;i<nbLayers;i++) {
                markerIdList.Add(layers[i].Id);
            }
            Parent.map.SetMarkerOpacityIdList(markerIdList.ToArray(), 0.0f);
        }
    }

    private string LineCategoryFormattingString() {
        if ((!isMobileView)&&(CollapsedSider)) {
            return "margin-left: 2pt;";
        }
        else {
            return "margin-left: 4pt;";
        }
    }


    private string LineButtonFormattingString(string textcolor, string color, bool display, int width) {
        string height;
        string removedFormattingString = "";
        string margin_string = "";
        if ((!isMobileView)&&(CollapsedSider)) {
            height = "30";
        }
        else {
            height = "40";
            margin_string = "margin-left: 3.5pt; margin-top: 3.5pt; margin-bottom: 3.5pt;";
        }

        if (display) {
            removedFormattingString = "border-style: none;";
        }
        else{
            removedFormattingString = "border-color: lightgrey; border-style: solid; border-width: 3px;";
            color = color + "80";
        }
        return ($"color: #{textcolor}; background: #{color}; min-width: {width}px; height: {height}px; {removedFormattingString} " +
                $"border-radius: 5px; {margin_string} padding: 0px 4px;");
    }

    private string LineIconFormattingString(string textcolor, string color, int iconWidth, int iconHeight) {
        return ($"color: #{textcolor}; background: #{color}; min-width: {iconWidth}px; height: {iconHeight}px; border-radius: 4px; padding: 3px; font-size: 75%; float: right; margin-right: 2pt; line-height: {iconHeight*7/11}px;");
    }

    private string LineIconFormatForVehiclePopup(string textcolor, string color, int iconWidth, int iconHeight) {
        return ($"color: #{textcolor}; background: #{color}; min-width: {iconWidth}px; min-height: {iconHeight}px; border-radius: 4px; font-size: 100%; margin-right: 7pt; margin-bottom: 5pt; line-height: {iconHeight*16/20}px;");
    }

    private string VariantButtonFormattingString(string color, float opacity) {
        string rgba = GenerateRgba(color, opacity);

        //return $"display: inline-block; font-size: 10pt; color: {fontColor}; background-color: {rgba}; width: {lineButtonWidth*85/40}px; height: 60px; white-space: normal; overflow:hidden";
        return $"background-color: {rgba}; width: {lineButtonWidth*85/40}px; height: 60px; margin-bottom: 3.5pt; border-style: none;";
    }

    private string VariantTextFormattingString(string fontColor, float opacity) {
        if(opacity < 0.25f) {
            fontColor = "black";
        }
        else{
            fontColor = "#" + fontColor;
        }

        return $"display: -webkit-box; font-size: 10pt; color: {fontColor}; white-space: normal; -webkit-line-clamp: 2; -webkit-box-orient: vertical;  text-overflow: ellipsis; overflow: hidden;";
    }

    private string GetStateColor(int state) {
        switch(state){
            case 0: return "green";

            case 1: return "orange";

            case 3: return "red";

            default: return "lightgrey";
        }
    }

    private string StateCircleFormattingString(int state, int size) {
        string color = GetStateColor(state);
        return $"color: {color}; font-size: {size}pt; position:relative; bottom: {size}pt;";
    }

    private string GetLoadColor(int load) {
        switch(load){
            case 0: return "grey";

            case 1: return "green";

            case 2: return "orange";

            case 3: return "red";

            default: return "grey";
        }
    }

    private string PeopleIconFormattingString(int load) {
        string color = GetLoadColor(load);
        return $"color: {color}; font-size: 12pt; position:absolute; transform: translateX({menuWidth - 75}px) translateY(-200%);";
    }

    public string GenerateRgba(string backgroundColor, float backgroundOpacity) {
        string specifier = "G";
        int rgb = int.Parse(backgroundColor, System.Globalization.NumberStyles.HexNumber);
        int r = (rgb >> 16) & 0xFF;
        int g = (rgb >> 8) & 0xFF;
        int b = rgb  & 0xFF;
        return string.Format("rgba({0}, {1}, {2}, {3});", r, g, b, backgroundOpacity.ToString(specifier, CultureInfo.InvariantCulture));
    }

    private string RemoveLineFromString(string input) {
        return input.Remove(0, 6);
    }

    //private BlazorLeaflet.Models.Icon GetVehicleIcon(string iconString, string lineColor, string foreColor, int load, int state) {
    //    return new BlazorLeaflet.Models.Icon { 
    //    Url = $"<div style=\"background-repeat: no-repeat; background-position: center; background: #{foreColor}; border-radius: 50%; height: 26pt; width:26pt;\">" +
    //          $"<div style=\"background-repeat: no-repeat; background-position: center; background: #{lineColor};" +
    //          $"border-radius: 50%; height: 24pt; width:24pt; transform:translate(1pt,1pt);\">" +
    //          $"<div style=\"background-repeat: no-repeat; background-position: center; background: rgb(255,255,255, 1);" +
    //          $"border-radius: 50%; height: 22pt; width:22pt; transform:translate(1pt,1pt);\">" +
    //          $"<i style=\"color:#{lineColor}; font-size: 14pt; position:relative; left: 0.3rem;top: 0.3rem;\" class=\"{iconString}\"></i>" +
    //          $"<i style=\"color:{GetStateColor(state)}; font-size: 0.3rem; position:relative; right: 1.3rem; bottom: 0.5rem;\" class=\"fas fa-circle\"></i></div></div></div>"};
    //
    //}

    private BlazorLeaflet.Models.Icon GetVehicleIcon(string iconString, string lineColor, string foreColor, int load, int state) {
        string vehicleIconLeftPosition = "0.3";
        if(iconString == "fas fa-train") {
            vehicleIconLeftPosition = "0.35";
        }
        return new BlazorLeaflet.Models.Icon { 
        Url = $"<div style=\"background-repeat: no-repeat; background-position: center; background: #{lineColor}; border-radius: 50%; height: 26pt; width:26pt;\">" +
              $"<div style=\"background-repeat: no-repeat; background-position: center; background: rgb(255,255,255, 1);" +
              $"border-radius: 50%; height: 22pt; width:22pt; transform:translate(2pt,2pt);\">" +
              $"<i style=\"color:#{lineColor}; font-size: 14pt; position:relative; left: {vehicleIconLeftPosition}rem; top: 0.35rem;\" class=\"{iconString}\"></i>" +
              $"<i style=\"color:{GetStateColor(state)}; font-size: 0.3rem; position:relative; right: 1.5rem; bottom: 0.6rem;\" class=\"fas fa-circle\"></i></div></div></div>"};

    }

    public void ResetSiderTabsActiveKey (bool collapsed) {
        if(collapsed) {
            JSInterops.SetActiveTab(jsRuntime, "tabs_carto", "lines");
            StateHasChanged();
        }
    }

    private void LineButtonClickHandler(LineSelection selectedLine) {
        Flowly.Api.Map.ApiLine line = linesDict[selectedLine.LineId];
        if (selectedLine.Display == true) {
            if(removeLines) {
                HideSelectedLine(selectedLine);
            } else {
                DisplaySelectedLine(selectedLine, true);
            }
            selectedLine.Display = false;
            selectedLine.Develop = false;
            HideVehiclesFromLine(selectedLine.LineId, true);
            if(CheckAllCategoryLinesDisplayStatus(line.Category, false)) {
                categoryHideDict[line.Category] = true;
            }
        }
        else{
            DisplaySelectedLine(selectedLine, false);
            selectedLine.Display = true;
            DisplayVehiclesFromLine(selectedLine.LineId, true);
            if(CheckAllCategoryLinesDisplayStatus(line.Category, true)) {
                categoryHideDict[line.Category] = false;
            }
        }
        StateHasChanged();
    }

    private void LineButtonMouseEnterEvent(LineSelection buttonLine) {
        List<Path> pathList = new List<Path>();
        Path path;
        if(removeLines) {
            List<String> markerIdList = new List<String>();
            foreach (var selectedLine in SelectedLines) {
                if((selectedLine.Display == true)&&(selectedLine != buttonLine)) {
                    Layer[] layers = lineLayersDict[selectedLine.LineId];
                    for (int i = 0; i<NUMBER_LAYERS_POLYLINE; i++) {
                        path = (Path)layers[i];
                        path.StrokeOpacity = 0.0;
                        pathList.Add(path);
                    }
                    for (int i = NUMBER_LAYERS_POLYLINE; i<layers.Length; i++) {
                        markerIdList.Add(layers[i].Id);
                    }
                    HideVehiclesFromLine(selectedLine.LineId, false);
                }
            }
            Parent.map.SetMarkerOpacityIdList(markerIdList.ToArray(), 0.0f);
        }
        else{
            foreach (var selectedLine in SelectedLines) {
                if((selectedLine.Display == true)&&(selectedLine != buttonLine)) {
                    Layer[] layers = lineLayersDict[selectedLine.LineId];
                    path = (Path)layers[NUMBER_LAYERS_POLYLINE-1];
                    path.StrokeOpacity = 0.7;
                    path.StrokeColor = System.Drawing.Color.FromArgb(159, 166, 173);
                    pathList.Add(path);
                    HideVehiclesFromLine(selectedLine.LineId, false);
                }
            }
        }
        Parent.map.SetPathOptionsList(pathList.ToArray());

        if(buttonLine.Display == false) {
            DisplaySelectedLine(buttonLine, false);
            DisplayVehiclesFromLine(buttonLine.LineId, false);
        }
        for(int i =0;i<NUMBER_LAYERS_POLYLINE;i++){
            Layer polylineLayer = lineLayersDict[buttonLine.LineId][i];
            Parent.map.BringPathToFront((Path)polylineLayer);
        }
        HideNotAssignedVehicles();

        // Fit Map to the line bounds ?
        //Flowly.Api.Map.ApiLine line = linesDict[buttonLine.LineId];
        //Flowly.Api.Map.ApiVariation variant = line.Roads[buttonLine.Direction].Variations[buttonLine.VariationNumber];
        //Single[] bounds = StringUtils.ExtractBoundsFromString(variant.Bounds);
        //Parent.map.FitBounds(new PointF(bounds[0], bounds[1]), new PointF(bounds[2], bounds[3]));
    }

    private void LineButtonMouseLeaveEvent(LineSelection buttonLine) {
        List<Path> pathList = new List<Path>();
        Path path;

        if(removeLines) {
            List<String> markerIdList = new List<String>();
            foreach (var selectedLine in SelectedLines) {
                if((selectedLine.Display == true)&&(selectedLine != buttonLine)) {
                    Layer[] layers = lineLayersDict[selectedLine.LineId];
                    for (int i = 0; i<NUMBER_LAYERS_POLYLINE; i++) {
                        path = (Path)layers[i];
                        path.StrokeOpacity = 1.0;
                        pathList.Add(path);
                    }
                    for (int i = NUMBER_LAYERS_POLYLINE; i<layers.Length; i++) {
                        markerIdList.Add(layers[i].Id);
                    }
                    DisplayVehiclesFromLine(selectedLine.LineId, false);
                }
            } 
            Parent.map.SetMarkerOpacityIdList(markerIdList.ToArray(), 1.0f);
        }
        else{
            foreach (var selectedLine in SelectedLines) {
                if((selectedLine.Display == true)&&(selectedLine != buttonLine)) {
                    Flowly.Api.Map.ApiLine line = linesDict[selectedLine.LineId];
                    string color = line.Color;
                    int colorInt = int.Parse(color, System.Globalization.NumberStyles.HexNumber);
                    Layer[] layers = lineLayersDict[selectedLine.LineId];
                    path = (Path)layers[NUMBER_LAYERS_POLYLINE-1];
                    path.StrokeOpacity = 1.0;
                    path.StrokeColor = System.Drawing.Color.FromArgb(colorInt);
                    pathList.Add(path);
                    DisplayVehiclesFromLine(selectedLine.LineId, false);
                }
            }
        }

        Parent.map.SetPathOptionsList(pathList.ToArray());
        DisplayNotAssignedVehicles();

        if(buttonLine.Display == false) {
            if(removeLines) {
                HideSelectedLine(buttonLine);
            } else {
                DisplaySelectedLine(buttonLine, true);
            }
            HideVehiclesFromLine(buttonLine.LineId, false);
        }
    }

    private bool CheckIfAllLinesAreHidden() {
        bool result = true;
        foreach( var selectedLine in SelectedLines)
        {
            if (selectedLine.Display == true)
            {
                result = false;
            }
        }
        return result;
    }

    private void ToggleLineRemoval() {
        removeLines = !removeLines;
        if(removeLines) {
            foreach( var selectedLine in SelectedLines)
            {
                if (selectedLine.Display == false)
                {
                    HideSelectedLine(selectedLine);
                }
            }
        } else {
            foreach( var selectedLine in SelectedLines)
            {
                if (selectedLine.Display == false)
                {
                    DisplaySelectedLine(selectedLine, true);
                }
            }

        }
    }

    private void ChangeSelectedLineDirection(LineSelection selectedLine) {
        RemoveSelectedLine(selectedLine);
        if(selectedLine.Direction == 0) {
            selectedLine.Direction = 1;
        }
        else {
            selectedLine.Direction = 0;
        }
        DisplaySelectedLineFirstTime(selectedLine);
        StateHasChanged();
    }

    private void ChangeSelectedVariation(LineSelection selectedLine, int variationNumber) {
        RemoveSelectedLine(selectedLine);
        selectedLine.VariationNumber = variationNumber;
        DisplaySelectedLineFirstTime(selectedLine);
        StateHasChanged();
    }


    private void RemoveSelectedLineFromDisplay(LineSelection selectedLine) {
        if(removeLines) {
            HideSelectedLine(selectedLine);
        } else {
            DisplaySelectedLine(selectedLine, true);
        }
        selectedLine.Display = false;
        selectedLine.Develop = false;
        HideVehiclesFromLine(selectedLine.LineId, true);
        StateHasChanged();
    }

    private void ToggleSelectedLineDevelopment(LineSelection selectedLine) {
        selectedLine.Develop = !selectedLine.Develop;
        StateHasChanged();
    }

    private void ResetDevelopFields() {
        foreach (LineSelection selectedLine in SelectedLines) {
            selectedLine.Develop = false;
        }
    }

    private void StationMouseEnterEvent(LineSelection selectedLine, int stationIndex) {
        int stationLayerIndex = stationIndex + NUMBER_LAYERS_POLYLINE;
        Layer[] layers = lineLayersDict[selectedLine.LineId];
        Layer stationLayer = layers[stationLayerIndex];
        Parent.map.OpenPopup(stationLayer);
        closeStationPopup = true;
    }

    private void StationClickEvent() {
        closeStationPopup = false;
    }

    private void StationMouseLeaveEvent(LineSelection selectedLine, int stationIndex) {
        if(closeStationPopup) {
            int stationLayerIndex = stationIndex + NUMBER_LAYERS_POLYLINE;
            Layer[] layers = lineLayersDict[selectedLine.LineId];
            Layer stationLayer = layers[stationLayerIndex];
            Parent.map.ClosePopup(stationLayer);
        }
    }

    private void HideAllLines() {
        foreach (LineSelection selectedLine in SelectedLines) {
            if(removeLines) {
                HideSelectedLine(selectedLine);
            } else {
                DisplaySelectedLine(selectedLine, true);
            }
            HideVehiclesFromLine(selectedLine.LineId, true);
            selectedLine.Display = false;
            selectedLine.Develop = false;
        }
        foreach (var category in categoryHideDict.Keys) {
            categoryHideDict[category] = true;
        }
        ResetSiderTabsActiveKey(true);
    }

    private void DisplayAllLines() {
        foreach (LineSelection selectedLine in SelectedLines) {

            DisplaySelectedLine(selectedLine,false);
            DisplayVehiclesFromLine(selectedLine.LineId, true);
            selectedLine.Display = true;
        }
        foreach (var category in categoryHideDict.Keys) {
            categoryHideDict[category] = false;
        }
    }

    private void OnVehicleSearchClear() {
        vehicleFilteringString="";
        FilterVehicles();
    }

    private void FilterVehicles() {
        List<String> markerIdListToHide = new List<String>();
        List<String> markerIdListToShow = new List<String>();
        if ((vehicleFilteringString != null) && (vehicleFilteringString != "")) {

            foreach (VehicleInfo vehicleInfo in vehiclesInfo) {
                bool vehicleFound = false;

                if(vehicleInfo.Position.Vehicle != null) {
                    if(VehicleFilterMatch(vehicleInfo.Position.Vehicle.ToLower())) {
                        vehicleFound=true;
                    }
                }
                else if (vehicleInfo.Position.VehicleId != null) {
                    if(VehicleFilterMatch(vehicleInfo.Position.VehicleId.ToString())) {
                        vehicleFound=true;
                    }
                }
                else {
                    foreach (var device in vehicleInfo.Position.Devices) {
                        if(VehicleFilterMatch(device.DeviceId)) {
                            vehicleFound=true;
                        }
                    }
                }

                if(vehicleFound) {
                    vehicleInfo.Filtered=false;
                    if(!vehicleInfo.Hidden) {
                        markerIdListToShow.Add(vehicleInfo.Layer.Id);
                    } 
                }
                else {
                    vehicleInfo.Filtered=true;
                    markerIdListToHide.Add(vehicleInfo.Layer.Id);
                }
            }
            if (!hideVehicles) {
                Parent.map.SetMarkerOpacityIdList(markerIdListToHide.ToArray(), 0.0f);
                Parent.map.SetMarkerOpacityIdList(markerIdListToShow.ToArray(), 1.0f);
                StateHasChanged();
            }
        }
        else {
            if (vehicleInitializationDone) {
                foreach (VehicleInfo vehicleInfo in vehiclesInfo) {
                    vehicleInfo.Filtered=false;
                    if(!vehicleInfo.Hidden) {
                        markerIdListToShow.Add(vehicleInfo.Layer.Id);
                    } 
                }
                if (!hideVehicles) {
                    Parent.map.SetMarkerOpacityIdList(markerIdListToShow.ToArray(), 1.0f);
                    StateHasChanged();
                }
            }
            else {
                foreach (VehicleInfo vehicleInfo in vehiclesInfo) {
                    vehicleInfo.Filtered=false;
                }
            }
        }
        HideVehiclesFromNonSelectedLines();
    }

    private void HideVehiclesFromNonSelectedLines() {
        HashSet<string> linesHidden = new HashSet<string>();
        foreach (LineSelection selection in SelectedLines) {
            if (selection.Display==false) {
                linesHidden.Add(selection.LineId);
            }
        }

        List<String> markerIdListToHide = new List<String>();
        List<String> markerIdListToShow = new List<String>();
        foreach(VehicleInfo vehicleInfo in vehiclesInfo) {
            if (vehicleInfo.Assigned) {
                if (linesHidden.Contains(vehicleInfo.Position.RealTime.Line.Id)){
                    if(!vehicleInfo.Filtered) {
                        markerIdListToHide.Add(vehicleInfo.Layer.Id);
                    }
                    vehicleInfo.Hidden=true;
                }
                else {
                    if(vehicleInfo.Hidden) {
                        markerIdListToShow.Add(vehicleInfo.Layer.Id);
                    }
                    vehicleInfo.Hidden=false;
                }
            }
        }

        if (!hideVehicles) {
            Parent.map.SetMarkerOpacityIdList(markerIdListToHide.ToArray(), 0.0f);
            Parent.map.SetMarkerOpacityIdList(markerIdListToShow.ToArray(), 1.0f);
        }
    }

    private void HideVehiclesFromLine(string LineId, bool updateFlag) {
        List<String> markerIdListToHide = new List<String>();
        List<ApiPosition> filteredPositionsToRemove = new List<ApiPosition>();
        foreach (VehicleInfo vehicleInfo in vehiclesInfo) {
            if (vehicleInfo.Assigned) {
                if (vehicleInfo.Position.RealTime.Line.Id == LineId) {
                    markerIdListToHide.Add(vehicleInfo.Layer.Id);
                    if (updateFlag) {
                        vehicleInfo.Hidden=true;
                    }  
                }
            }
        }
        if (!hideVehicles) {
            Parent.map.SetMarkerOpacityIdList(markerIdListToHide.ToArray(), 0.0f);
        }
    }

    private void DisplayVehiclesFromLine(string LineId, bool updateFlag) {
        List<String> markerIdListToShow = new List<String>();
        List<ApiPosition> hiddenPositionsToRemove = new List<ApiPosition>();
        foreach (VehicleInfo vehicleInfo in vehiclesInfo) {
            if (vehicleInfo.Assigned) {
                if (vehicleInfo.Position.RealTime.Line.Id == LineId) {
                    if (!vehicleInfo.Filtered) {
                        markerIdListToShow.Add(vehicleInfo.Layer.Id);  
                    }
                    if (updateFlag) {
                        vehicleInfo.Hidden=false;
                    } 
                }
            }
        }
        if (!hideVehicles) {
            Parent.map.SetMarkerOpacityIdList(markerIdListToShow.ToArray(), 1.0f);
        }
    }

    private void HideNotAssignedVehicles() {
        if (!hideVehicles) {
            List<String> markerIdListToHide = new List<String>();
            foreach (VehicleInfo vehicleInfo in vehiclesInfo) {
                if((!vehicleInfo.Assigned)&&(!vehicleInfo.Hidden)) {
                    vehicleInfo.Hidden = true;
                    markerIdListToHide.Add(vehicleInfo.Layer.Id);
                }
            }
            Parent.map.SetMarkerOpacityIdList(markerIdListToHide.ToArray(), 0.0f);
        }
    }

    private void DisplayNotAssignedVehicles() {
        if (!hideVehicles) {
            List<String> markerIdListToShow = new List<String>();
            foreach (VehicleInfo vehicleInfo in vehiclesInfo) {
                if((!vehicleInfo.Assigned)&&(vehicleInfo.Hidden)) {
                    vehicleInfo.Hidden = false;
                    if (!vehicleInfo.Filtered) {
                        markerIdListToShow.Add(vehicleInfo.Layer.Id);
                    } 
                }
            }
            Parent.map.SetMarkerOpacityIdList(markerIdListToShow.ToArray(), 1.0f);
        }
    }

    private bool VehicleFilterMatch(string input) {
        return input.Contains(vehicleFilteringString.ToLower());
    }

    private void VehicleMouseEnterEvent(Layer vehicleLayer) {
        Parent.map.OpenPopup(vehicleLayer);
    }

    private void VehicleMouseLeaveEvent(Layer vehicleLayer) {
        Parent.map.ClosePopup(vehicleLayer);
    }

    private void VehicleClickEvent(Flowly.Api.Positions.ApiPosition position) {
        PointF center = new PointF((float)position.Latitude, (float)position.Longitude);
        Parent.map.SetView(center, 14.0f, true);
    }

    private void ToggleVehiclesDisplay() {
        if (hideVehicles){
            UnHideAllVehicles();
        }
        else {
            HideAllVehicles();
        }
    }

    private void HideAllVehicles() {
        List<String> markerIdList = new List<String>();
        foreach (VehicleInfo vehicleInfo in vehiclesInfo) {
            markerIdList.Add(vehicleInfo.Layer.Id);
        }
        Parent.map.SetMarkerOpacityIdList(markerIdList.ToArray(), 0.0f);
        hideVehicles = true;
    }

    private void UnHideAllVehicles() {
        List<String> markerIdList = new List<String>();
        foreach (VehicleInfo vehicleInfo in vehiclesInfo) {
            if ((!vehicleInfo.Filtered)&&(!vehicleInfo.Hidden)) {
                markerIdList.Add(vehicleInfo.Layer.Id);
            }   
        }
        Parent.map.SetMarkerOpacityIdList(markerIdList.ToArray(), 1.0f);
        hideVehicles = false;
    }

    private void DisplayAllVehicles() {
        vehiclesInfo = new List<VehicleInfo>();
        foreach (var position in apiPositions.Positions) {
            string popupContent = CreateVehiclePopupContent(position);
            string lineColor, foreColor;
            bool assigned = true;
            if ((position.RealTime != null) && (position.RealTime.Line != null) && !string.IsNullOrEmpty(position.RealTime.Line.Id)) {
                Flowly.Api.Map.ApiLine line = linesDict[position.RealTime.Line.Id];
                lineColor = line.Color;
                foreColor = line.ForeColor;
            }
            else {
                lineColor= "808080";
                foreColor = "FFFFFF";
                assigned = false;
            }
            Marker vehicleMarker = new Marker((float)position.Latitude, (float)position.Longitude) {
                    Icon = GetVehicleIcon(position.Icon, lineColor, foreColor, position.Load, position.State),
                    Popup = new Popup {
                        Content = popupContent,
                        Offset = new System.Drawing.Point(14, 10),
                        ShowCloseButton = false
                    }, //new Popup
                    ZIndexOffset=100
            }; // new Marker
            Parent.map.AddLayer(vehicleMarker);
            VehicleInfo vehicleInfo = new VehicleInfo(position, false, false, assigned, vehicleMarker);
            vehiclesInfo.Add(vehicleInfo);
        } //foreach
        hideVehicles = false;
    }

    private void RemoveAllVehicles() {
        if(vehicleInitializationDone)
        {
            foreach (VehicleInfo vehicleInfo in vehiclesInfo) {
                Parent.map.RemoveLayer(vehicleInfo.Layer);
            } 
            hideVehicles = true;
        }
    }

    private string CreateVehiclePopupContent (ApiPosition position) {
        string popupContent = $"<div style= \"min-width:150pt; font-size: 10pt; height: 20pt; background-color: #e4e4e4; border-radius: 5px; padding:5pt; justify-content:center;" +
                              $"text-align: center; margin:10pt 0pt; line-height:11pt;\"> {GetStateIcon(position.State)}" +
                              $"<i style=\"color: black; font-size: 10pt;\" class=\"{position.Icon}\"></i>" +
                              $"<span style= \"font-size: 10pt; padding: 0 10pt;\">{GetVehicleInfo(position.Vehicle, position.VehicleId)}</span>" +
                              $"{GetPopupLoadIcon(GetLoadColor(position.Load))}</div>" +
                              $"<div style= \"margin-bottom: 5px;\">";
        if ((position.RealTime != null) && (position.RealTime.Line != null) && !string.IsNullOrEmpty(position.RealTime.Line.Id)) {
            Flowly.Api.Map.ApiLine line = linesDict[position.RealTime.Line.Id];
            popupContent += $"<div style=\"text-align: center; margin-bottom: 5px; margin-left: 8px;\"><span class=\"badge\" style=\"{LineIconFormatForVehiclePopup(line.ForeColor, line.Color, 50, 20)}\">" +
                            $"{RemoveLineFromString(line.Id)}</span>" +
                            $"<span class=\"badge\" style=\"{LineIconFormatForVehiclePopup("000000", "DCDCDC", 50, 20)}\">" +
                            $"{GetDirectionString(position.RealTime.Direction)}</span>" +
                            $"<span class=\"badge\" style=\"{LineIconFormatForVehiclePopup("FFFFFF", GetDelayColor(position.RealTime.Delay), 50, 20)}\">" +
                            $"{GetDelayString(position.RealTime.Delay)}</button></span>";
            if ((position.RealTime.Station != null) && !string.IsNullOrEmpty(position.RealTime.Station.Id)) {
                popupContent += $"<div style=\"text-align: center; font-size: 10pt; line-height:15pt; font-weight: bold; margin-bottom: 5px;\">{stationsDict[position.RealTime.Station.Id].Name}</div>";
            }  
        }
        foreach (ApiDevice device in position.Devices) {
            popupContent +=  $"<div style= \"font-size: 9pt; text-align: center; word-spacing: 3pt;\">" +
                              $"{GetStateIcon(device.State)} {device.DeviceId}</div>";
        }
        popupContent +="</div>";

        return popupContent; 
    }

    private string GetDirectionString(int direction) {
        switch (direction) {
            case 0:
                return GetLocalizedString("Aller");
            case 1:
                return GetLocalizedString("Retour");
            default:
                return GetLocalizedString("Direction Inconnue");
        }
    }

    private string GetDelayColor(int delay) {
        switch (delay) {
            case 1:
                return "008000";
            case 2:
                return "FF0000";
            case 3:
                return "FF8C00";
            case 0:
            default:
                return GetLocalizedString("Retard Inconnu");
        }  
    }

    private string GetDelayString(int delay) {
        switch (delay) {
            case 1:
                return GetLocalizedString("A l'heure");
            case 2:
                return GetLocalizedString("En avance");
            case 3:
                return GetLocalizedString("En retard");
            case 0:
            default:
                return GetLocalizedString("Retard Inconnu");
        }
    }

    private string GetVehicleInfo(string matriculation, int? stock_number) {
        if((matriculation != null)&&(stock_number!= null)) {
            return $"{matriculation} ({stock_number})";
        }
        else {
            return GetLocalizedString("Non Renseigné");
        }
    }

    private int GetHeaderHeight() {
        return (windowHeight-100)*10/28;
    }

    private string GetStateIcon(int State) {
        return $"<i style=\"color: {GetStateColor(State)}; font-size: 4pt; position:relative; left: -2pt; bottom: 4pt;\" class=\"fas fa-circle\"></i>";
    }

    private string GetPopupLoadIcon(string color) {
        string style = $"color: {color}; font-size: 10pt; padding-right:3px;";
        if (color=="grey") {
            style += " opacity:0.75;";
        }
        return $"<i style=\"{style}\" class=\"fas fa-users\"></i>";
    }

    private string GetPopupRealTimeIcon(bool realTime) {
        string style;
        if(realTime) {
            style = "color: green; font-size: 9pt;";
        }
        else {
            style = "color: grey; font-size: 9pt; opacity:0.75;";
        }
        return $"<i  style=\"{style}\" class=\"fas fa-wifi\"></i>";
    }

    private DateTime UnixTimeStampStringToDateTime(string timeStampString) {
        double timeStamp;
        Double.TryParse(timeStampString.Substring(6,13), out timeStamp);
        DateTime dateTime = new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc);
        dateTime = dateTime.AddMilliseconds(timeStamp).ToLocalTime();
        return dateTime;
    }

    private string FormatPassingTime(string timeStampString) {

        TimeZoneInfo conversion = TimeZoneConverter.TZConvert.GetTimeZoneInfo(apiMap.Location);
        DateTime passingTime = TimeZoneInfo.ConvertTime(UnixTimeStampStringToDateTime(timeStampString), conversion);
        return passingTime.ToString("t");
    }

    private string GetLocalizedString(string input)
    {
        return (string)Localize[input];
    }
}
